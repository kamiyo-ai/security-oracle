/**
 * Enhanced Exploit Analytics Engine
 * Provides deep analysis of exploit patterns, trends, and insights
 */

import {
  EnhancedExploit,
  AttackType,
  AttackPattern,
  ExploitFamily,
  AttackPatternAnalysis,
  TemporalTrend,
  EnhancedAnalyticsResponse
} from '../types/enhanced.js';

export class ExploitAnalyzer {

  /**
   * Enrich basic exploit data with enhanced analytics
   */
  enrichExploit(basicExploit: any): EnhancedExploit {
    return {
      ...basicExploit,
      exploit_id: this.generateExploitId(basicExploit),
      attack_pattern: this.analyzeAttackPattern(basicExploit),
      vulnerability: this.extractVulnerabilityDetails(basicExploit),
      attribution: this.analyzeAttribution(basicExploit),
      timeline: this.buildTimeline(basicExploit),
      post_mortem: this.generatePostMortem(basicExploit),
      data_quality_score: this.assessDataQuality(basicExploit),
      verification_status: 'verified',
      sources: ['kamiyo_api']
    };
  }

  /**
   * Generate unique exploit ID based on key characteristics
   */
  private generateExploitId(exploit: any): string {
    const hash = this.simpleHash(
      `${exploit.protocol}-${exploit.chain}-${exploit.timestamp}-${exploit.loss_usd}`
    );
    return `EXP-${hash.substring(0, 12).toUpperCase()}`;
  }

  /**
   * Analyze attack pattern from exploit description and characteristics
   */
  private analyzeAttackPattern(exploit: any): AttackPattern {
    const attackType = this.classifyAttackType(exploit.description, exploit.attack_vector);
    const complexity = this.calculateComplexity(exploit);

    return {
      type: attackType,
      complexity,
      similar_attacks: [], // Would query historical database
      exploit_family: this.determineExploitFamily(attackType),
      attack_vector: this.extractAttackVectors(exploit.description),
      techniques_used: this.extractTechniques(exploit.description)
    };
  }

  /**
   * Classify attack type from description using keyword matching
   */
  private classifyAttackType(description: string, attack_vector?: string): AttackType {
    const lower = (description + ' ' + (attack_vector || '')).toLowerCase();

    if (lower.includes('flash loan')) return AttackType.FLASH_LOAN;
    if (lower.includes('reentrancy') || lower.includes('re-entrancy')) return AttackType.REENTRANCY;
    if (lower.includes('oracle') && lower.includes('manipulat')) return AttackType.ORACLE_MANIPULATION;
    if (lower.includes('price manipulat')) return AttackType.PRICE_MANIPULATION;
    if (lower.includes('access control') || lower.includes('unauthorized')) return AttackType.ACCESS_CONTROL;
    if (lower.includes('logic error') || lower.includes('business logic')) return AttackType.LOGIC_ERROR;
    if (lower.includes('front run') || lower.includes('front-run')) return AttackType.FRONT_RUNNING;
    if (lower.includes('sandwich')) return AttackType.SANDWICH_ATTACK;
    if (lower.includes('bridge')) return AttackType.BRIDGE_EXPLOIT;
    if (lower.includes('governance')) return AttackType.GOVERNANCE_ATTACK;
    if (lower.includes('overflow') || lower.includes('underflow')) return AttackType.INTEGER_OVERFLOW;
    if (lower.includes('economic') || lower.includes('game theory')) return AttackType.ECONOMIC_ATTACK;
    if (lower.includes('phish')) return AttackType.PHISHING;
    if (lower.includes('private key') || lower.includes('compromised key')) return AttackType.PRIVATE_KEY_COMPROMISE;

    return AttackType.UNKNOWN;
  }

  /**
   * Calculate attack complexity score (1-10)
   */
  private calculateComplexity(exploit: any): number {
    let complexity = 5; // Base complexity

    // Increase for higher loss (sophisticated attacks often yield more)
    if (exploit.loss_usd > 10_000_000) complexity += 2;
    else if (exploit.loss_usd > 1_000_000) complexity += 1;

    // Increase for multi-step attacks
    const description = exploit.description.toLowerCase();
    if (description.includes('multi')) complexity += 1;
    if (description.includes('complex')) complexity += 1;
    if (description.includes('sophisticated')) complexity += 1;

    // Flash loans add complexity
    if (description.includes('flash loan')) complexity += 1;

    return Math.min(10, Math.max(1, complexity));
  }

  /**
   * Determine exploit family based on attack type
   */
  private determineExploitFamily(attackType: AttackType): string {
    const familyMap: Record<AttackType, string> = {
      [AttackType.FLASH_LOAN]: 'Composability Exploits',
      [AttackType.REENTRANCY]: 'State Manipulation',
      [AttackType.ORACLE_MANIPULATION]: 'Data Feed Attacks',
      [AttackType.PRICE_MANIPULATION]: 'Market Manipulation',
      [AttackType.ACCESS_CONTROL]: 'Authorization Failures',
      [AttackType.LOGIC_ERROR]: 'Implementation Bugs',
      [AttackType.FRONT_RUNNING]: 'MEV Attacks',
      [AttackType.SANDWICH_ATTACK]: 'MEV Attacks',
      [AttackType.BRIDGE_EXPLOIT]: 'Cross-Chain Attacks',
      [AttackType.GOVERNANCE_ATTACK]: 'Protocol Governance',
      [AttackType.INTEGER_OVERFLOW]: 'Arithmetic Errors',
      [AttackType.ECONOMIC_ATTACK]: 'Economic Exploits',
      [AttackType.PHISHING]: 'Social Engineering',
      [AttackType.PRIVATE_KEY_COMPROMISE]: 'Key Management',
      [AttackType.UNKNOWN]: 'Unclassified'
    };

    return familyMap[attackType];
  }

  /**
   * Extract attack vectors from description
   */
  private extractAttackVectors(description: string): string[] {
    const vectors: string[] = [];
    const lower = description.toLowerCase();

    if (lower.includes('smart contract')) vectors.push('Smart Contract Vulnerability');
    if (lower.includes('oracle')) vectors.push('Oracle Dependency');
    if (lower.includes('governance')) vectors.push('Governance Mechanism');
    if (lower.includes('bridge')) vectors.push('Cross-Chain Bridge');
    if (lower.includes('front')) vectors.push('Transaction Ordering');
    if (lower.includes('pool')) vectors.push('Liquidity Pool');
    if (lower.includes('token')) vectors.push('Token Contract');

    return vectors.length > 0 ? vectors : ['Unknown'];
  }

  /**
   * Extract techniques used (MITRE ATT&CK style)
   */
  private extractTechniques(description: string): string[] {
    const techniques: string[] = [];
    const lower = description.toLowerCase();

    if (lower.includes('flash loan')) techniques.push('T1-Flash Loan Financing');
    if (lower.includes('reentrancy')) techniques.push('T2-Reentrancy Exploitation');
    if (lower.includes('manipulat')) techniques.push('T3-Price/Data Manipulation');
    if (lower.includes('drain')) techniques.push('T4-Fund Draining');
    if (lower.includes('mint')) techniques.push('T5-Unauthorized Minting');

    return techniques;
  }

  /**
   * Extract vulnerability details
   */
  private extractVulnerabilityDetails(exploit: any) {
    const severity = exploit.severity || 'medium';
    const cvssScore = this.severityToCVSS(severity);

    return {
      cwe_id: this.mapToCWE(exploit.attack_vector),
      cvss_score: cvssScore,
      exploitability: this.calculateExploitability(exploit),
      impact_scope: this.determineImpactScope(exploit),
      affected_components: [exploit.protocol],
      patch_available: false,
      patch_url: undefined
    };
  }

  /**
   * Map severity to CVSS score
   */
  private severityToCVSS(severity: string): number {
    const map: Record<string, number> = {
      'critical': 9.5,
      'high': 7.5,
      'medium': 5.0,
      'low': 2.5
    };
    return map[severity.toLowerCase()] || 5.0;
  }

  /**
   * Map attack vector to CWE ID
   */
  private mapToCWE(attack_vector: string): string {
    if (!attack_vector) return 'CWE-693';

    const lower = attack_vector.toLowerCase();
    if (lower.includes('reentrancy')) return 'CWE-841';
    if (lower.includes('overflow')) return 'CWE-190';
    if (lower.includes('access')) return 'CWE-284';
    if (lower.includes('logic')) return 'CWE-691';

    return 'CWE-693'; // Protection Mechanism Failure
  }

  /**
   * Calculate exploitability score
   */
  private calculateExploitability(exploit: any): number {
    let score = 50; // Base exploitability

    // Known exploits are more exploitable
    if (exploit.severity === 'critical') score += 30;
    else if (exploit.severity === 'high') score += 20;

    // Large losses indicate successful exploitation
    if (exploit.loss_usd > 1_000_000) score += 10;

    return Math.min(100, score);
  }

  /**
   * Determine impact scope
   */
  private determineImpactScope(exploit: any): string[] {
    const scope = ['financial']; // Always financial in DeFi

    if (exploit.loss_usd > 10_000_000) {
      scope.push('reputational');
    }

    if (exploit.description.toLowerCase().includes('halt')) {
      scope.push('availability');
    }

    return scope;
  }

  /**
   * Analyze attacker attribution
   */
  private analyzeAttribution(exploit: any) {
    return {
      attacker_address: 'unknown',
      attacker_profile: 'Unknown Actor',
      attribution_confidence: 0,
      related_incidents: [],
      attacker_type: 'unknown' as const,
      motive: 'Financial gain',
      laundering_trail: undefined
    };
  }

  /**
   * Build exploit timeline
   */
  private buildTimeline(exploit: any) {
    const timestamp = new Date(exploit.timestamp);

    return {
      vulnerability_introduced: 'unknown',
      first_detected: exploit.timestamp,
      exploit_duration: 3600, // Default 1 hour
      response_initiated: new Date(timestamp.getTime() + 3600000).toISOString(),
      patch_deployed: 'unknown',
      recovery_complete: 'unknown',
      recovery_time: 86400 // Default 24 hours
    };
  }

  /**
   * Generate post-mortem analysis
   */
  private generatePostMortem(exploit: any) {
    return {
      root_cause: exploit.description,
      contributing_factors: this.extractContributingFactors(exploit),
      mitigation_steps: this.generateMitigationSteps(exploit),
      lessons_learned: this.generateLessonsLearned(exploit),
      code_fix_url: '',
      audit_findings: undefined,
      preventability_score: this.calculatePreventability(exploit)
    };
  }

  /**
   * Extract contributing factors
   */
  private extractContributingFactors(exploit: any): string[] {
    const factors: string[] = [];
    const desc = exploit.description.toLowerCase();

    if (desc.includes('audit')) factors.push('Insufficient audit coverage');
    if (desc.includes('test')) factors.push('Inadequate testing');
    if (desc.includes('complex')) factors.push('High code complexity');
    if (desc.includes('upgrade')) factors.push('Unsafe upgrade mechanism');

    return factors.length > 0 ? factors : ['Code vulnerability'];
  }

  /**
   * Generate mitigation steps
   */
  private generateMitigationSteps(exploit: any): string[] {
    const attackType = this.classifyAttackType(exploit.description, exploit.attack_vector);

    const mitigations: Partial<Record<AttackType, string[]>> = {
      [AttackType.FLASH_LOAN]: [
        'Implement reentrancy guards',
        'Add flash loan checks',
        'Use time-weighted average prices'
      ],
      [AttackType.REENTRANCY]: [
        'Apply checks-effects-interactions pattern',
        'Use ReentrancyGuard modifier',
        'Conduct thorough testing'
      ],
      [AttackType.ORACLE_MANIPULATION]: [
        'Use multiple oracle sources',
        'Implement price deviation checks',
        'Add circuit breakers'
      ],
      [AttackType.UNKNOWN]: [
        'Conduct security audit',
        'Implement monitoring',
        'Add emergency pause mechanism'
      ]
    };

    return mitigations[attackType] || mitigations[AttackType.UNKNOWN] || [
      'Conduct security audit',
      'Implement monitoring',
      'Add emergency pause mechanism'
    ];
  }

  /**
   * Generate lessons learned
   */
  private generateLessonsLearned(exploit: any): string[] {
    return [
      'Regular security audits are essential',
      'Implement defense in depth',
      'Monitor on-chain activity for anomalies',
      'Have incident response plan ready'
    ];
  }

  /**
   * Calculate preventability score
   */
  private calculatePreventability(exploit: any): number {
    let score = 70; // Base preventability

    const desc = exploit.description.toLowerCase();
    if (desc.includes('known') || desc.includes('public')) score += 20;
    if (desc.includes('audit')) score += 10;
    if (desc.includes('warning')) score += 10;

    return Math.min(100, score);
  }

  /**
   * Assess data quality score
   */
  private assessDataQuality(exploit: any): number {
    let score = 50;

    if (exploit.protocol) score += 10;
    if (exploit.chain) score += 10;
    if (exploit.loss_usd > 0) score += 10;
    if (exploit.description && exploit.description.length > 50) score += 10;
    if (exploit.timestamp) score += 10;

    return Math.min(100, score);
  }

  /**
   * Analyze temporal trends
   */
  analyzeTemporalTrends(exploits: EnhancedExploit[]): TemporalTrend[] {
    const trends: Map<string, TemporalTrend> = new Map();

    for (const exploit of exploits) {
      const period = this.getPeriod(exploit.timestamp);

      if (!trends.has(period)) {
        trends.set(period, {
          period,
          exploit_count: 0,
          total_loss_usd: 0,
          avg_severity: 0,
          dominant_attack_type: ''
        });
      }

      const trend = trends.get(period)!;
      trend.exploit_count++;
      trend.total_loss_usd += exploit.loss_usd;
    }

    return Array.from(trends.values()).sort((a, b) =>
      a.period.localeCompare(b.period)
    );
  }

  /**
   * Get period identifier from timestamp
   */
  private getPeriod(timestamp: string): string {
    const date = new Date(timestamp);
    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
  }

  /**
   * Simple hash function
   */
  private simpleHash(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16);
  }

  /**
   * Generate analytics response
   */
  generateAnalytics(exploits: EnhancedExploit[]): EnhancedAnalyticsResponse {
    const totalLoss = exploits.reduce((sum, e) => sum + e.loss_usd, 0);

    const attackPatternDist: Record<string, number> = {};
    const severityDist: Record<string, number> = {};
    const chainDist: Record<string, number> = {};

    for (const exploit of exploits) {
      const attackType = exploit.attack_pattern.type;
      attackPatternDist[attackType] = (attackPatternDist[attackType] || 0) + 1;

      severityDist[exploit.severity] = (severityDist[exploit.severity] || 0) + 1;
      chainDist[exploit.chain] = (chainDist[exploit.chain] || 0) + 1;
    }

    return {
      exploits,
      analytics: {
        total_count: exploits.length,
        total_loss_usd: totalLoss,
        avg_loss_per_exploit: totalLoss / exploits.length,
        attack_pattern_distribution: attackPatternDist,
        severity_distribution: severityDist,
        chain_distribution: chainDist,
        temporal_trends: this.analyzeTemporalTrends(exploits),
        attack_families: []
      },
      insights: {
        emerging_threats: this.identifyEmergingThreats(exploits),
        high_risk_patterns: this.identifyHighRiskPatterns(exploits),
        recommended_defenses: this.generateDefenseRecommendations(exploits)
      }
    };
  }

  /**
   * Identify emerging threats
   */
  private identifyEmergingThreats(exploits: EnhancedExploit[]): string[] {
    // Look for attack types increasing in frequency
    const recentExploits = exploits.filter(e =>
      new Date(e.timestamp) > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
    );

    const attackCounts: Record<string, number> = {};
    for (const exploit of recentExploits) {
      const type = exploit.attack_pattern.type;
      attackCounts[type] = (attackCounts[type] || 0) + 1;
    }

    return Object.entries(attackCounts)
      .filter(([_, count]) => count >= 2)
      .map(([type, count]) => `${type} (${count} recent incidents)`)
      .slice(0, 5);
  }

  /**
   * Identify high-risk patterns
   */
  private identifyHighRiskPatterns(exploits: EnhancedExploit[]): string[] {
    const patterns: string[] = [];

    const criticalExploits = exploits.filter(e => e.severity === 'critical');
    if (criticalExploits.length > 5) {
      patterns.push(`High frequency of critical exploits (${criticalExploits.length})`);
    }

    const highLossExploits = exploits.filter(e => e.loss_usd > 10_000_000);
    if (highLossExploits.length > 0) {
      patterns.push(`${highLossExploits.length} exploits with >$10M loss`);
    }

    return patterns;
  }

  /**
   * Generate defense recommendations
   */
  private generateDefenseRecommendations(exploits: EnhancedExploit[]): string[] {
    const recommendations: Set<string> = new Set();

    for (const exploit of exploits.slice(0, 20)) {
      const mitigations = this.generateMitigationSteps(exploit);
      mitigations.forEach(m => recommendations.add(m));
    }

    return Array.from(recommendations).slice(0, 5);
  }
}
